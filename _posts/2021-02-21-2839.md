---
layout: post
title:  "[백준 2839] 설탕 배달 "
date: 2021-02-21
author: yudini
categories: Algorithm
comments: true
tags: Algorithm Greedy 그리디 
---

## 문제

상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.

상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.

상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)

## 출력

상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.

* 문제 링크: <https://www.acmicpc.net/problem/2839>


<hr>

## 내 풀이

최대한 적은 봉지를 가져가기 위해서는 한 봉지에 더 많은 설탕을 넣어야한다. 이 문제는 다양한 방법으로 풀 수 있다. 

5키로짜리 봉지 i개(0개 1개 2개 .....) 사용 했을 때와 3키로짜리 봉지 j개(0개 1개 2개 .....) 를 더한 값이 n일 때를 구해서 i+j를 sum에 넣어주는 식이다. 5키로 짜리 봉지를 0부터 시작해서 큰 값으로 갱신해주는 방식인데 백준에 제출했을 때는 맞았다. 

~~~C++ 
#include <stdio.h>                                                                   
int main(){
    int n,i,j;
    int sum=0;
    scanf("%d",&n);
    for(i=0;5*i<=n;i++){
        for(j=0;5*i+3*j<=n;j++){
            if(5*i+3*j==n)
                sum=i+j;
        }
    }

    if(sum==0)
        sum=-1;
    printf("%d",sum);
    return 0;
}

~~~
<hr>

그렇지만 나는 좀 더 확실하게 그리디 방식으로 풀기를 원해서 다시 다른 방법을 찾았다. 위에 방법은 5키로 짜리를 증가해주는 식이였는데 이 방법은 5키로 짜리를 최대 개수부터 시작해서 줄어드는 식이다. 이중 반복문도 사용하지 않고 최대 개수 부터 시작하기 때문에 나눠 떨어지면 바로 반복문을 탈출하여 이 방법이 시간 복잡도 상 훨씬 좋은 방법인 것 같다.   
<hr>

~~~C++
#include <stdio.h>
int main(){
    int n;
    int count=0;
    scanf("%d",&n);
    count=n/5;
    if(n%5!=0){
        while(count>=0){
            if((n-5*count)%3==0){
                count+=(n-5*count)/3;
                break;
            }
            count--;
        }
    }
    printf("%d",count);
    return 0;
}

~~~
<hr>

-- 근데 이 문제를 DP로도 풀 수가 있다네????? 생각하지도 못했는데 다음에 한번 도전해 봐야겠다.

<hr>


<h4>&#8251;질문과 오류사항, 더 좋은 코드가 있다면 댓글로 알려주세요!</h4>

