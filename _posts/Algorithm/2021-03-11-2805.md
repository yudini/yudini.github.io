---
layout: post
title:  "[백준 2805] 나무자르기 "
date: 2021-03-11
author: yudini
categories: Algorithm
comments: true
tags: Algorithm BinarySearch
---

## 문제

상근이는 나무 M미터가 필요하다. 근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. 정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기를 이용해서 나무를 구할것이다.

목재절단기는 다음과 같이 동작한다. 먼저, 상근이는 절단기에 높이 H를 지정해야 한다. 높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. 그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. 따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. 예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. 상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, 상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다) 절단기에 설정할 수 있는 높이는 양의 정수 또는 0이다.

상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. 이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 나무의 수 N과 상근이가 집으로 가져가려고 하는 나무의 길이 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)

둘째 줄에는 나무의 높이가 주어진다. 나무의 높이의 합은 항상 M보다 크거나 같기 때문에, 상근이는 집에 필요한 나무를 항상 가져갈 수 있다. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0이다.

## 출력

첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 가지고 있으면 1을, 아니면 0을 공백으로 구분해 출력한다.

* 문제 링크: <https://www.acmicpc.net/problem/2805>


<hr>
## 내 풀이
이 문제는 어느 위치 즉 몇 미터를 자를지가 가장 핵심이다. 먼저 간단하게 생각을 해보면 1미터부터 제일 큰 나무 까지 다 잘라본다고 생각하면 된다. 그런 후 잘린 나무 길이의 값과 필요한 나무 값을 비교하면 된다. 

근데 이런식으로 1미터씩 순서대로 자르다보면 오랜시간이 걸린다. 그래서 필요한 것이 이진탐색이다.
가장 큰 나무를 기준으로 절반 위치를 자르고 잘린 나무들의 길이를 더해 그 값을 필요한 나무길이와 비교한다.  

**잘린 나무들의 합 < 필요한 나무길이** 이면

나무를 더 자를 수 있다는 뜻이므로 더 아래쪽을 자르면 되서 high 값을 바꿔준다. 

**잘린 나무들의 합 > 필요한 나무길이** 이면

나무를 덜 자를 수 있다는 뜻이므로 그 합들을 따로 저장을 해놓고 더 위쪽을 자르고 그렇게 해서 잘린 나무들의 길이와 이전에 구해놓은 합들과 비교해주면된다. 

<hr>

~~~c++
#include <iostream>                                                          
#include <algorithm>

using namespace std;

int main(){

    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    int array[1000000];
    int N,M,high=0;
    cin>>N>>M;
    for(int i=0;i<N;i++){
        cin>>array[i];
        high=max(high,array[i]);
    }

    int mid=high/2, low=0; 
    long long result=0;
    while(low<=high){
        long long sum=0;
        for(int i=0;i<N;i++){
            if(array[i]>mid)
                sum+=array[i]-mid;
        }
        if(sum>=M){
            if(result<mid)
                result = mid;
            low=mid+1;
            mid=(low+high)/2;

        }
        else{
            high=mid-1;
            mid=(low+high)/2;
        }
    }
    cout<<result;
}

~~~

<hr>


<h4>&#8251;질문과 오류사항, 더 좋은 코드가 있다면 댓글로 알려주세요!</h4>
