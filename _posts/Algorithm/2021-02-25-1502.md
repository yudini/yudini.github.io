---
layout: post
title:  "[백준 1520] 내리막길 "
date: 2021-02-25
author: yudini
categories: Algorithm
comments: true
tags: Algorithm DP DynamicProgramming graph
---

## 문제

여행을 떠난 세준이는 지도를 하나 구하였다. 이 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.

현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다. 그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다.

지도가 주어질 때 이와 같이 제일 왼쪽 위 지점에서 출발하여 제일 오른쪽 아래 지점까지 항상 내리막길로만 이동하는 경로의 개수를 구하는 프로그램을 작성하시오

## 입력

첫째 줄에는 지도의 세로의 크기 M과 가로의 크기 N이 빈칸을 사이에 두고 주어진다. 이어 다음 M개 줄에 걸쳐 한 줄에 N개씩 위에서부터 차례로 각 지점의 높이가 빈 칸을 사이에 두고 주어진다. M과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수이다.

## 출력

첫째 줄에 이동 가능한 경로의 수 H를 출력한다. 모든 입력에 대하여 H는 10억 이하의 음이 아닌 정수이다.

* 문제 링크: <https://www.acmicpc.net/problem/1520>

<hr>

## 내 풀이

이 문제를 보자마자 dfs,bfs가 생각났다. 한 지점에서 갈 수 있는 방향은 지도의 크기 내에서 상하좌우로 총 네곳이다. 이동 할 범위를 지정해주기 위해 dx[], dy[] 배열을 만들어주었다. 이동 후 그 좌표가 지도 내에 있다면 이동 전의 높이와 비교한다. 높이가 낮은 곳으로만 이동할 수 있으니 이동 후 좌표가 더 낮다는 조건을 넣어준다. 

여기까지는 문제의 조건을 맞춰준 것이다. 이 다음이 이제 dfs와 dp를 사용해야한다. 먼저 visited를 -1로 초기화 해준다. (0으로 초기화 하지 않는 이유는 방문은 했어도 이동할 곳이 없는 경우가 있기 때문이다.) 

dfs니까 먼저 한 경로로 끝까지 탐색할 것이고 먼저 제일 오른쪽 아래 칸에 도착했다면 한가지 방법으로 도착했으니 1을 리턴해준다.

visited[][]에 dfs()의 리턴 값을 계속 더해준다. 또 vistited[][]가 -1이 아니라면, 즉 이미 방문한 경우라면 이미 해당경로를 탐색했으므로 또 다시 dfs로 돌 필요가 없다.***(아무래도 이게 dp를 사용하는 핵심이다!)***

이렇게 되면 처음 dfs를 호출한 인덱스 [0][0]에 총 경로가 저장이 될 것이다.
 

**그림으로 그려서 생각했을 때는 맨 왼쪽 위부터 갈 수 있는 경로를 찾고 맨 오른쪽에 총 경로를 넣어주는 식으로 생각했다. 근데 dfs는 재귀로 풀기 때문에 결국 시작점이 제일 마지막에 return 될 것이다.** 

<hr>

이 문제는 dfs와 재귀에 대해 확실하게 알지 못한다면 답을 봐도 이해하기 어려운 문제이다. 
나는 설명을 못하고.... dp나 dfs는 설명하기 참 어려운 것 같다. 더 열심히 공부해서 설명 좀 잘해봐야지..


<hr>

~~~C++
#include <iostream>                                             


using namespace std;

int N,M;

int map[500][500];
int visited[500][500];   //{0,}
int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0};

int dfs(int x,int y){
    if(x==M-1&&y==N-1)
        return 1;        //visited[x][y];
    if(visited[x][y]!=-1)
        return visited[x][y];        //visited[x][y]++;
    visited[x][y]=0;
    for(int i=0;i<4;i++){
        int x2=x+dx[i];
        int y2=y+dy[i];
        if(x2>=0&&x2<M&&y2>=0&&y2<N){
            if(map[x2][y2]<map[x][y]){
                visited[x][y]+=dfs(x2,y2);    //dfs(x2,y2);
            }
        }
    }
    return visited[x][y];

}


int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin>>M>>N;
    for(int i=0;i<M;i++){
        for(int j=0;j<N;j++){
            cin>>map[i][j];
            visited[i][j]=-1;
        }
    }
    int result = dfs(0,0);
    cout<<result;

}

~~~

<hr>

<h4>&#8251;질문과 오류사항, 더 좋은 코드가 있다면 댓글로 알려주세요!</h4>