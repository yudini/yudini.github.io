---
layout: post
title:  "[백준 11726] 2xn 타일링 "
date: 2021-02-18
author: yudini
categories: Algorithm
comments: true
tags: Algorithm DP DynamicProgramming
---

## 문제

2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.

아래 그림은 2×5 크기의 직사각형을 채운 한 가지 방법의 예이다.

## 입력

첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)

## 출력

첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.

* 문제 링크: <https://www.acmicpc.net/problem/11726>


<hr>

## 내 풀이

먼저 dp[n]은 2xn 크기의 직사각형을 채우는 방법의 수를 10,007 로 나눈 나머지를 저장한다.

2x5까지 그림을 그려가면서 세보았더니 dp[i]=dp[i-1]+dp[i-2] 라는 점화식을 구할 수 있었다. 

이 문제가 생각보다 쉬워 일일이 세서 점화식을 쉽게 구했지만 이렇게 끝내기에는 찝찝했다. 

2x1, 2x2는 직접 구해야한다. 2x1=1 2x2=2, 그리하여 dp[1]=1 dp[2]=2이다.

이제 2x3부터 생각을 해보아야한다.

2x3을 시작할 때 처음 직사각형을 채우는 방법은 두가지이다. 2x1 하나로 먼저 채우거나 1x2 두개로 채우거나.(2x3뿐만아니라 모든 2xn 직사각형도 마찬가지이다. )

2x1로 채웠을 경우 남는 직사각형 부분은 2x2 부분이다. 

1x2로 채웠을 경우 남는 직사각형 부분은 2x1 부분이다.

이런식으로 생각하다보면 2x4도 맨 처음 2x1로 채웠을 경우 남는 직사각형 부분은 2x3이고 1x2로 채웠을 경우 남는 직사각형 부분은 2x2부분이다. 

결국 직접 하나씩 직사각형 개수를 셀 때와 같은 
**dp[i]=dp[i-1]+dp[i-2]**
 라는 점화식을 얻을 수 있다.

#### * dp[i]에 직사각형의 개수가 아닌 나머지를 넣는 이유 *

처음에는 dp에 직사각형 개수를 저장하고 출력할 때 10007로 나눠주었다. 예제의 답은 맞게 나왔지만 백준에 제출했더니 틀렸다고 나왔다.
그 이유를 확인하기 위해 큰 숫자를 넣어보었다. 먼저 나는 dp를 int형으로 선언해 주었는데, 나머지가 아닌 개수를 저장하게 되면 dp[50]등 숫자가 커졌을 때 개수가 int 범위를 넘어가서 쓰레기 값이 출력되는 것을 확인했다. 그래서 나머지를 dp에 저장해주었다.  

<hr>

~~~C++
#include <iostream>

using namespace std;

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    int n;
    int dp[1001]={0,};

    cin>>n;

    dp[1]=1;
    dp[2]=2;
    for(int i=3;i<=n;i++){
        dp[i]=(dp[i-1]+dp[i-2])%10007;   //dp[i]=dp[i-1]+dp[i-2]       dp[50]-int범위 넘어감.
    }

    cout<<dp[n];    //dp[n]%10007          

    return 0;
}


~~~

<hr>


<h4>&#8251;질문과 오류사항, 더 좋은 코드가 있다면 댓글로 알려주세요!</h4>