---
layout: post
title:  "[백준 1110] 더하기 사이클 "
date: 2022-02-12
author: yudini
categories: Algorithm
comments: true
tags: Algorithm Baekjoon BOJ
---

## 문제

0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때 다음과 같은 연산을 할 수 있다. 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. 다음 예를 보자.

26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다.

위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다.

N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N이 주어진다. N은 0보다 크거나 같고, 99보다 작거나 같은 정수이다.

## 출력

첫째 줄에 N의 사이클 길이를 출력한다.

* 문제 링크: <https://www.acmicpc.net/problem/1110>


<hr>

## 내 풀이

먼저 0과 99사이의 정수(N)를 입력받고 이 N을 k에 저장한다. (원래 수와 같은지 확인하기 위해)

1. 그 후 이 N을 두자리로 만든 후의 주어진 수의 오른쪽 수 즉 일의 자리를 구해주어야 한다.

   자리수에 상관없이 N을 10으로 나눴을 때의 나머지로 구할 수 있다. 이 오른쪽 수가 십의 자리로 가야하기 때문에 이 수에 10을 곱해주어 왼쪽자리 수를 구한다. 

2. 오른쪽 자리는 주어진 수의 십의 자리와 일의 자리를 더하고 그렇게 해서 구한 수의 오른쪽 자리(일의 자리)로 구한다. 

   먼저 일의 자리는 N을 10으로 나눈 나머지이고, 십의 자리는 N을 10으로 나눈 몫이다. 이렇게 나머지와 몫을 더하고 구한 값의 오른쪽(일의 자리) 자리를 구해야 하기 때문에 10으로 나눈 나머지를 구해준다. 

3. 1번과 2번에서 구한 값들을 더해주어 다시 N에 저장하고 사이클  수를 확인하기 위해 count를 1씩 증가시켜준다. 그런 다음 원래 수인 k와 N을 비교해서 같다면 반복문을 나와 사이클 수인 count를 출력하면 된다.  

~~~C++

#include <stdio.h>
#include <stdlib.h>

int main()
{
    int N,count=0;
    scanf("%d",&N);                                                    
    if(N<0||99<N)
        scanf("%d",&N);
    int k=N;
    while(1){
        N=(N%10)*10+((N%10+N/10)%10);
        count++;
        if(k==N)
            break;
    }
    printf("%d",count);

    return 0;
}

~~~

<hr> 


<h4>&#8251;질문과 오류사항, 더 좋은 코드가 있다면 댓글로 알려주세요!</h4>